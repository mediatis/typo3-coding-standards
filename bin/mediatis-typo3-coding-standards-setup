#!/usr/bin/env php
<?php
function includeIfExists(string $file): bool
{
    return file_exists($file) && include $file;
}
if (
    !includeIfExists(__DIR__ . '/../../../autoload.php') &&
    !includeIfExists(__DIR__ . '/../vendor/autoload.php') &&
    !includeIfExists(__DIR__ . '/../../../../../vendor/autoload.php')
) {
    fwrite(STDERR, 'Install dependencies using Composer.'.PHP_EOL);
    exit(1);
}
$supportedTypo3PackageKeys = ['typo3/cms','typo3/cms-core'];
$supportedTypo3Versions = [11.5, 12.4];
$supportedPhpVersions = [8.1, 8.2];
$supportedPhpPackageKeys = ['php'];
$binDirectory = $_composer_bin_dir ?? __DIR__ . '/../../../../bin';
$targetPackageDirectory = realpath($binDirectory . '/../..');
$codingStandardsPackageDirectory = realpath(__DIR__ . '/..');
$requiredFolderPaths = ['Classes', 'Tests'];
$examplePackagePath = 'example-extension';

class MediatisCodingStandardsSetup
{
    public function __construct(
        protected string $targetPackageDirectory,
        protected string $codingStandardsPackageDirectory,
        protected array $requiredFolderPaths,
        protected string $examplePackageDirectory,
        protected array $supportedTypo3PackageKeys,
        protected array $supportedTypo3Versions,
        protected array $supportedPhpPackageKeys,
        protected array $supportedPhpVersions,
    ) {

    }

    protected function extractVersions(string $constraint, array $allowedVersions): array {
        preg_match('/\^(\d+\.\d+)/', $constraint, $matches);
        $latestVersion = $matches[1];

        // Ensure the latest version is within the allowed versions range
        if (version_compare($latestVersion, end($allowedVersions), '>')) {
            $latestVersion = end($allowedVersions);
        }

        // Extract all versions up to the latest allowed version
        $versions = [];
        foreach ($allowedVersions as $version) {
            if (version_compare($version, $latestVersion, '>=')) {
                $versions[] = $version;
            }
        }

        return $versions;
    }
    protected function updateFolderStructure(string $filePath): void
    {
        if (!str_starts_with($filePath, $this->targetPackageDirectory)) {
            throw new Exception(sprintf('file path "%s" does not seem to be within the package directory.', $filePath));
        }
        $pathParts = explode('/', $filePath);
        array_pop($pathParts);
        $folderPath = implode('/', $pathParts);
        if (!is_dir($folderPath)) {
            mkdir($folderPath, recursive: true);
        }
    }

    protected function getExtensionKeyFromComposerData(array $data): string
    {
        if (!isset($data['extra']['typo3/cms']['extension-key'])) {
            throw new Exception('No extension key found in composer.json');
        }
        return $data['extra']['typo3/cms']['extension-key'];
    }

    protected function getDependencyVersionConstraintsFromComposerData(string $key, $allowedVersions, string $type = "full"): ?array
    {
        $versions = null;
        $composerFilePath = $this->targetPackageDirectory . '/composer.json';
        $composerFileContents = file_get_contents($composerFilePath);
        if ($composerFileContents === false) {
            throw new Exception(sprintf('File "%s" not found!', $composerFilePath));
        }
        $composerFileContentsAsArray = json_decode($composerFileContents, true, 512, JSON_THROW_ON_ERROR);
        if (isset($composerFileContentsAsArray['require'][$key])) {
            switch ($type) {
                case 'major':
                    $versions = $this->extractVersions($composerFileContentsAsArray['require'][$key], $allowedVersions);
                    foreach ($versions as $key => $number) {
                        $versions[$key] = $number;
                    }
                    break;
                default:
                    $versions = $this->extractVersions($composerFileContentsAsArray['require'][$key], $allowedVersions);
            }
        }
        return $versions;
    }

    protected function updateFileContentsComposerJson(string $sourceContents, string $targetContents, array $config): string
    {
        $sourceData = json_decode($sourceContents, true, 512, JSON_THROW_ON_ERROR);
        $targetData = json_decode($targetContents, true, 512, JSON_THROW_ON_ERROR);

        foreach ($config as $key => $merge) {
            if (!isset($sourceData[$key])) {
                throw new Exception(sprintf('Key "%s" not found in source data!', $key));
            }
            if ($merge && isset($targetData[$key]) && is_array($targetData[$key])) {
                foreach ($sourceData[$key] as $configKey => $configValue) {
                    if (array_key_exists($configKey, $targetData[$key])) {
                        unset($targetData[$key][$configKey]);
                    }
                    $targetData[$key][$configKey] = $configValue;
                }
            } else {
                $targetData[$key] = $sourceData[$key];
            }
        }

        $sourceExtensionKey = $this->getExtensionKeyFromComposerData($sourceData);
        $targetExtensionKey = $this->getExtensionKeyFromComposerData($targetData);
        foreach ($targetData['scripts']['link-extension'] ?? [] as $index => $value) {
            $targetData['scripts']['link-extension'][$index] = str_replace($sourceExtensionKey, $targetExtensionKey, $value);
        }

        return json_encode($targetData, JSON_PRETTY_PRINT | JSON_THROW_ON_ERROR | JSON_UNESCAPED_SLASHES) . PHP_EOL;
    }
    protected function updateFileContentsYaml(string $sourceContents, string $targetContents, array $config): string
    {
        $sourceData = Symfony\Component\Yaml\Yaml::parse($sourceContents);
        $targetData = Symfony\Component\Yaml\Yaml::parse($targetContents);

        if (!$this->checkKeysRecursive($config, $sourceData)) {
            throw new Exception(sprintf('Configured key not found in source data!'));
        }
        \TYPO3\CMS\Core\Utility\ArrayUtility::mergeRecursiveWithOverrule($sourceData, $config);

        foreach ($config as $key => $merge) {

            if ($this->checkKeysRecursive($config, $targetData)) {
                \TYPO3\CMS\Core\Utility\ArrayUtility::mergeRecursiveWithOverrule($targetData[$key], $sourceData[$key]);
            } else {
                $targetData[$key] = $sourceData[$key];
            }
        }

        return Symfony\Component\Yaml\Yaml::dump($targetData, 99);
    }

    protected function updateFileContents(string $sourceContents, string $targetContents, string $filePath, array $config): string
    {
        switch ($filePath) {
            case 'composer.json':
                return $this->updateFileContentsComposerJson($sourceContents, $targetContents, $config);
            case '.github/workflows/ci.yml':
                return $this->updateFileContentsYaml($sourceContents, $targetContents, $config);
            default:
                throw new Exception(sprintf('No information how to process "%s" found!'), $filePath);
        }
    }

    protected function updateFile(string $filePath, ?string $targetFilePath = null, ?array $config = null): void
    {
        $sourcePath = $this->getSourcePath($filePath);
        $targetPath = $this->getTargetPath($targetFilePath ?? $filePath);
        $sourceContents = file_exists($sourcePath) ? file_get_contents($sourcePath) : '';
        if ($sourceContents === false) {
            //throw new Exception(sprintf('File "%s" not found!', $sourcePath));
        }
        if ($config !== null) {
            $targetContents = file_exists($targetPath) ? file_get_contents($targetPath) : '';
            if ($targetContents === false) {
                //throw new Exception(sprintf('File "%s" not found!', $targetPath));
            }
            $targetContents = $this->updateFileContents($sourceContents, $targetContents, $filePath, $config);
        } else {
            $targetContents = $sourceContents;
        }

        $this->updateFolderStructure($targetPath);
        file_put_contents($targetPath, $targetContents);
    }

    protected function getSourcePath(string $filePath): string
    {
        return $this->codingStandardsPackageDirectory . '/' . $this->examplePackageDirectory . '/' . $filePath;
    }

    protected function getTargetPath(string $filePath): string
    {
        return $this->targetPackageDirectory . '/'. $filePath;
    }

    protected function setupCsFixerConfig(): void
    {
        $this->updateFile('.php-cs-fixer.php');
    }

    protected function setupRectorConfig(): void
    {
        foreach ($this->supportedTypo3PackageKeys as $key) {
            $versionConstraint = $this->getDependencyVersionConstraintsFromComposerData($key, $this->supportedTypo3Versions, 'major');
            if ($versionConstraint) {
                $versionConstraint = reset($versionConstraint); // Only need lowest supported version
                break;
            }
        }
        if ($versionConstraint) {
            $sourceFilePath = match(intval($versionConstraint)) {
                11 => 'rector-typo3-11.php',
                12 => 'rector-typo3-12.php',
            };
            $this->updateFile(
                $sourceFilePath,
                'rector.php'
            );
        }
    }

    protected function setupPhpStanConfig(): void
    {
        $this->updateFile('phpstan.neon');
    }

    protected function setupGithubPipeline(): void
    {
        $typo3VersionConstraints = [];
        $phpVersionConstraints = [];
        foreach ($this->supportedTypo3PackageKeys as $key) {
            $versionConstraint = $this->getDependencyVersionConstraintsFromComposerData($key, $this->supportedTypo3Versions);
            if (!empty($versionConstraint)) {
                $typo3VersionConstraints = $versionConstraint;
                break;
            }
        }

        foreach ($this->supportedPhpPackageKeys as $key) {
            $versionConstraint = $this->getDependencyVersionConstraintsFromComposerData($key, $this->supportedPhpVersions);
            if (!empty($versionConstraint)) {
                $phpVersionConstraints = $versionConstraint;
                break;
            }
        }

        $this->updateFile('.github/workflows/ci.yml', null,
            [
                'jobs' => [
                    'php-lint' => [
                        'strategy' => [
                            'matrix' => [
                                'php-version' => $phpVersionConstraints
                            ]
                        ]
                    ],
                    'code-quality' => [
                        'strategy' => [
                            'matrix' => [
                                'php-version' => $phpVersionConstraints,
                                'typo3-version' => $typo3VersionConstraints
                            ]
                        ]
                    ],
                ]
            ]
        );
    }

    protected function checkKeysRecursive($config, $data): bool {
        foreach ($config as $key => $value) {
            if (is_array($value)) {
                if (!isset($data[$key]) || !is_array($data[$key])) {
                    return false;
                }
                // Recursively check nested arrays
                $this->checkKeysRecursive($value, $data[$key]);
            } else {
                if (!isset($data[$key])) {
                    return false;
                }
            }
        }
        return true;
    }

    protected function setupComposerJson(): void
    {
        $this->updateFile('composer.json', 'composer.json', [
            'scripts' => true,
            'scripts-descriptions' => true,
        ]);
    }

    protected function setupRequiredFolders(): void
    {
        foreach ($this->requiredFolderPaths as $requiredFolderPath) {
            if (!is_dir($this->getTargetPath($requiredFolderPath))) {
                $this->updateFile($requiredFolderPath . '/.gitkeep');
            }
        }
    }

    public function setup(): void
    {
        $this->setupCsFixerConfig();
        $this->setupRectorConfig();
        $this->setupPhpStanConfig();
        $this->setupGithubPipeline();
        $this->setupComposerJson();
        $this->setupRequiredFolders();
    }
}

print(PHP_EOL);
print('#####################################################' . PHP_EOL);
print('#         MEDIATIS - TYPO3 CODING STANDARDS         #' . PHP_EOL);
print('#####################################################' . PHP_EOL);
print(PHP_EOL);

print('Setting up configuration...');
try {
    $codingStandardsSetup = new MediatisCodingStandardsSetup(
        $targetPackageDirectory,
        $codingStandardsPackageDirectory,
        $requiredFolderPaths,
        $examplePackagePath,
        $supportedTypo3PackageKeys,
        $supportedTypo3Versions,
        $supportedPhpPackageKeys,
        $supportedPhpVersions
    );
    $codingStandardsSetup->setup();
    print(' success!' . PHP_EOL);
    print(PHP_EOL);
} catch (Exception $e) {
    print(' failed!' . PHP_EOL);
    print(PHP_EOL);
    print('Reason: ' . $e->getMessage() . PHP_EOL);
    print(PHP_EOL);
}
